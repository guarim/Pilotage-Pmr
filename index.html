<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Contr√¥le Arduino par les Yeux avec MediaPipe et Web Serial</title>
    <style>
        body { font-family: sans-serif; display: flex; flex-direction: column; align-items: center; }
        .container { position: relative; width: 640px; height: 480px; }
        #video, #output_canvas { position: absolute; top: 0; left: 0; }
        #output_canvas { transform: scaleX(-1); } /* Miroir pour une meilleure exp√©rience utilisateur */
        #controls { margin-top: 20px; padding: 10px; border: 1px solid #ccc; width: 640px; }
        .status { margin-top: 10px; font-weight: bold; }
        .active { color: green; }
        .inactive { color: red; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
</head>
<body>

    <h1>üëÅÔ∏è Contr√¥le Arduino par Mouvement des Yeux</h1>

    <div id="controls">
        <button id="connectButton">Connecter √† l'Arduino (Web Serial)</button>
        <div class="status">Statut de la Connexion: <span id="serialStatus" class="inactive">D√©connect√©</span></div>
        <div class="status">Statut du Programme: <span id="programStatus" class="inactive">En attente (Ouvrir Droit, Fermer Gauche)</span></div>
        <div class="status">Commandes Envoy√©es: <span id="commandSent">AUCUNE</span></div>
    </div>

    <div class="container">
        <video id="video" width="640" height="480" autoplay></video>
        <canvas id="output_canvas" width="640" height="480"></canvas>
    </div>

    <script>
        const videoElement = document.getElementById('video');
        const canvasElement = document.getElementById('output_canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const connectButton = document.getElementById('connectButton');
        const serialStatus = document.getElementById('serialStatus');
        const programStatus = document.getElementById('programStatus');
        const commandSent = document.getElementById('commandSent');

        // --- Variables Globales ---
        let port; // Objet pour la connexion s√©rie
        let writer; // Objet pour √©crire sur le port s√©rie

        let isProgramActive = false;
        let lastBlinkTime = 0;
        const FULL_CLOSE_DURATION = 2000; // 3 secondes
        const EYE_CLOSED_THRESHOLD = 0.25; // Seuil pour d√©terminer si l'≈ìil est ferm√© (ratio hauteur/largeur)
        const IRIS_MOVEMENT_THRESHOLD = 0.05; // Seuil de d√©placement de l'iris (position X)

        // Indice des points cl√©s dans Face Mesh pour les yeux et l'iris
        // Source: https://github.com/google/mediapipe/blob/master/mediapipe/modules/face_geometry/data/face_landmarks_with_iris.csv
        const LEFT_EYE_INDICES = [362, 382, 381, 380, 374, 390, 249, 263]; // Pour le ratio d'aspect de l'≈ìil gauche
        const RIGHT_EYE_INDICES = [33, 7, 163, 144, 145, 153, 154, 155];   // Pour le ratio d'aspect de l'≈ìil droit
        const LEFT_IRIS_CENTER_INDEX = 468;
        const RIGHT_IRIS_CENTER_INDEX = 473;
        const LEFT_EYE_HORIZONTAL_INDICES = [362, 263]; // C√¥t√©s de l'≈ìil gauche
        const RIGHT_EYE_HORIZONTAL_INDICES = [33, 133]; // C√¥t√©s de l'≈ìil droit

        // --- Fonctions Web Serial API ---

        connectButton.addEventListener('click', async () => {
            if (!('serial' in navigator)) {
                alert('Votre navigateur ne supporte pas l\'API Web Serial. Utilisez Chrome ou Edge (avec HTTPS).');
                return;
            }
            try {
                // Demander √† l'utilisateur de s√©lectionner le port
                port = await navigator.serial.requestPort();
                await port.open({ baudRate: 9600 }); // Assurez-vous que le d√©bit en bauds correspond √† celui de l'Arduino
                serialStatus.textContent = 'Connect√©';
                serialStatus.classList.replace('inactive', 'active');
                writer = port.writable.getWriter();
                alert('Connexion s√©rie √©tablie !');
            } catch (error) {
                console.error('Erreur de connexion s√©rie:', error);
                serialStatus.textContent = 'D√©connect√©';
                serialStatus.classList.replace('active', 'inactive');
                alert('Erreur de connexion s√©rie: ' + error.message);
            }
        });

        // Fonction pour envoyer une commande √† l'Arduino
        async function sendCommand(command) {
            if (writer) {
                try {
                    const data = new TextEncoder().encode(command + '\n'); // Ajouter un retour chariot pour l'Arduino
                    await writer.write(data);
                    commandSent.textContent = command;
                    console.log(`Commande envoy√©e: ${command}`);
                } catch (error) {
                    console.error('Erreur d\'√©criture sur le port s√©rie:', error);
                    commandSent.textContent = `ERREUR (${command})`;
                }
            } else {
                console.warn(`Tentative d'envoyer la commande ${command} sans connexion s√©rie.`);
            }
        }

        // --- Fonctions de D√©tection des Yeux ---

        // Calcul du Eye Aspect Ratio (EAR) pour l'ouverture de l'≈ìil
        function getEAR(landmarks, eyeIndices) {
            if (!landmarks || eyeIndices.some(idx => !landmarks[idx])) return 0;
            // Utilise 6 points (p1 √† p6)
            const p1 = landmarks[eyeIndices[0]]; // Coin ext√©rieur (par exemple, 33 ou 362)
            const p2 = landmarks[eyeIndices[1]];
            const p3 = landmarks[eyeIndices[2]];
            const p4 = landmarks[eyeIndices[3]]; // Coin int√©rieur
            const p5 = landmarks[eyeIndices[4]];
            const p6 = landmarks[eyeIndices[5]];

            // Distance euclidienne
            const dist = (pA, pB) => Math.sqrt(Math.pow(pA.x - pB.x, 2) + Math.pow(pA.y - pB.y, 2));

            // Calcul des distances verticales (p2-p6, p3-p5) et de la distance horizontale (p1-p4)
            const V1 = dist(p2, p6);
            const V2 = dist(p3, p5);
            const H = dist(p1, p4);

            // EAR = (V1 + V2) / (2 * H)
            return (V1 + V2) / (2.0 * H);
        }

        // Calcule la position horizontale de l'iris relative √† l'≈ìil (entre 0.0 et 1.0)
        function getRelativeIrisX(landmarks, irisIndex, horizontalIndices) {
            if (!landmarks || !landmarks[irisIndex] || horizontalIndices.some(idx => !landmarks[idx])) return 0.5;

            const iris = landmarks[irisIndex];
            const left = landmarks[horizontalIndices[0]]; // Coin gauche (ext√©rieur)
            const right = landmarks[horizontalIndices[1]]; // Coin droit (int√©rieur)

            // Interpolation lin√©aire de la position X de l'iris entre le coin gauche et le coin droit
            // X_rel = (X_iris - X_left) / (X_right - X_left)
            // Comme le rep√®re est invers√© sur l'axe X (miroir), on doit inverser les coins pour un sens de lecture normal (0=Gauche, 1=Droite)
            const totalWidth = right.x - left.x;
            if (totalWidth === 0) return 0.5; // √âviter la division par z√©ro

            const irisOffset = iris.x - left.x;
            let relativeX = irisOffset / totalWidth;

            // MediaPipe donne les coordonn√©es de 0 √† 1, en partant du coin sup√©rieur gauche.
            // Pour l'oeil GAUCHE (c√¥t√© droit de l'√©cran), l'iris bouge vers la gauche (valeur basse) quand on regarde √† gauche.
            // On inverse pour que 0 = Regard √† Gauche et 1 = Regard √† Droite.
            return 1.0 - relativeX; // Inversion du rep√®re MediaPipe
        }


        // --- Logique du Programme de Commande ---

        function processLandmarks(results) {
            const now = Date.now();
            let stateCommand = 'NONE';
            let isLeftClosed = false;
            let isRightClosed = false;

            if (results.multiFaceLandmarks.length > 0) {
                const landmarks = results.multiFaceLandmarks[0];

                // 1. Calcul des EARs pour l'ouverture des yeux
                const earLeft = getEAR(landmarks, LEFT_EYE_INDICES);
                const earRight = getEAR(landmarks, RIGHT_EYE_INDICES);

                isLeftClosed = earLeft < EYE_CLOSED_THRESHOLD;
                isRightClosed = earRight < EYE_CLOSED_THRESHOLD;

                // 2. Calcul de la position de l'iris gauche
                const irisLeftX = getRelativeIrisX(landmarks, LEFT_IRIS_CENTER_INDEX, LEFT_EYE_HORIZONTAL_INDICES);
                // Note : irisLeftX est maintenant: 0.0 (regard √† gauche) √† 1.0 (regard √† droite), 0.5 (centre)


                // --- Logique de Contr√¥le ---

                // **D√©sactivation Totale (Condition de S√©curit√©)**
                if (isLeftClosed && isRightClosed) {
                    if (lastBlinkTime === 0) {
                        lastBlinkTime = now; // D√©but du clignement
                    } else if (now - lastBlinkTime >= FULL_CLOSE_DURATION) {
                        if (isProgramActive || commandSent.textContent !== 'DISABLE_ALL') {
                            sendCommand('DISABLE_ALL');
                            isProgramActive = false;
                            lastBlinkTime = 0; // R√©initialiser le compteur
                            programStatus.textContent = 'D√âSACTIV√â (Clignement Long)';
                            programStatus.classList.replace('active', 'inactive');
                            return; // Arr√™ter le traitement pour ne pas envoyer d'autre commande
                        }
                    }
                } else {
                    lastBlinkTime = 0; // R√©initialiser le compteur si les deux yeux sont ouverts ou un seul est ferm√©
                }


                // **√âtape 1: Lancement du Programme (Programme Actif)**
                if (!isProgramActive) {
                    // Condition de lancement: ≈íil gauche ferm√© ET ≈íil droit ouvert
                    if (isLeftClosed && !isRightClosed) {
                        sendCommand('ACTIVATE_PROG');
                        isProgramActive = true;
                        programStatus.textContent = 'ACTIF (Sortie 1 ON)';
                        programStatus.classList.replace('inactive', 'active');
                        return;
                    }
                }

                // **√âtape 2: Contr√¥le des Sorties 2 et 3 (Programme Actif)**
                if (isProgramActive) {
                    // Condition : ≈íil droit ferm√©
                    if (isRightClosed) {
                        // D√©placement de l'iris gauche sur la gauche (valeur basse)
                        if (irisLeftX < (0.5 - IRIS_MOVEMENT_THRESHOLD)) {
                            stateCommand = 'TURN_LEFT'; // Piloter Sortie 2
                        }
                        // D√©placement de l'iris gauche sur la droite (valeur haute)
                        else if (irisLeftX > (0.5 + IRIS_MOVEMENT_THRESHOLD)) {
                            stateCommand = 'TURN_RIGHT'; // Piloter Sortie 3
                        }
                        // Iris en position initiale (centre)
                        else {
                            stateCommand = 'IRIS_CENTERED'; // D√©sactiver Sorties 2 et 3
                        }
                    }
                    // Si le droit est ouvert, on n'envoie aucune commande de mouvement (Sorties 2/3 restent dans leur dernier √©tat ou d√©sactiv√©es)
                    // On pourrait aussi ajouter une logique pour d√©sactiver les sorties 2 et 3 si l'≈ìil droit s'ouvre.
                    else {
                        // Si on ouvre l'oeil droit alors que le programme √©tait actif (Sortie 1 d√©j√† ON), on d√©sactive les sorties 2 et 3
                        stateCommand = 'IRIS_CENTERED';
                    }

                    // Envoi de la commande de l'√©tape 2 (uniquement si diff√©rente de la derni√®re commande non-NONE)
                    if (stateCommand !== 'NONE') {
                         if (stateCommand !== 'IRIS_CENTERED') { // Envoie les commandes TURN_LEFT/TURN_RIGHT
                            sendCommand(stateCommand);
                        } else if (commandSent.textContent === 'TURN_LEFT' || commandSent.textContent === 'TURN_RIGHT') {
                            // D√©sactive si la derni√®re commande √©tait un mouvement
                            sendCommand(stateCommand);
                        }
                    }

                }

            } else {
                // Pas de visage d√©tect√© - peut-√™tre r√©initialiser la d√©tection apr√®s un certain temps.
                lastBlinkTime = 0;
            }
        }


        // --- Configuration et Lancement de MediaPipe Face Mesh ---

        const faceMesh = new FaceMesh({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
        }});

        faceMesh.setOptions({
            maxNumFaces: 1,
            refineLandmarks: true, // Am√©liore la pr√©cision des iris
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        faceMesh.onResults(function(results) {
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

            if (results.multiFaceLandmarks) {
                for (const landmarks of results.multiFaceLandmarks) {
                    // Dessiner le maillage du visage
                    drawConnectors(canvasCtx, landmarks, FACEMESH_TESSELATION,
                                   {color: '#C0C0C070', lineWidth: 1});
                    // Dessiner les contours des yeux
                    drawConnectors(canvasCtx, landmarks, FACEMESH_LEFT_EYE, {color: '#30FF30'});
                    drawConnectors(canvasCtx, landmarks, FACEMESH_RIGHT_EYE, {color: '#30FF30'});
                    // Dessiner les contours des iris
                    drawConnectors(canvasCtx, landmarks, FACEMESH_LEFT_IRIS, {color: '#FF3030'});
                    drawConnectors(canvasCtx, landmarks, FACEMESH_RIGHT_IRIS, {color: '#FF3030'});
                }
            }
            canvasCtx.restore();

            // Ex√©cuter la logique de commande APR√àS le dessin
            processLandmarks(results);
        });

        // Lancer la webcam
        const camera = new Camera(videoElement, {
            onFrame: async () => {
                await faceMesh.send({image: videoElement});
            },
            width: 640,
            height: 480
        });
        camera.start();

    </script>
</body>
</html>
